/*******************************************************************************
 * Copyright 2002-2009  Xilinx Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
/*
 * 
 *
 * 
 */

package net.sf.openforge.app;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

import net.sf.openforge.app.project.Option;
import net.sf.openforge.lim.CodeLabel;

/**
 * The ForgeFileHandler is the central authority for all files generated by the
 * compiler. This class operates by allowing classes to register a particular
 * File and associate it with a unique handle of type {@link ForgeFileKey}. Any
 * class which needs to refer to or use one of the generated files, can obtain
 * the File object for that output file via the specified handle.
 * 
 * <p>
 * TBD: It would be beneficial to further isolate the classes which are
 * generating output by creating a list of 'services' that the different outputs
 * of the compiler satisfy. In this way, a class could query the file handler
 * for the File (or set of files) which satisfy a particular service type (eg
 * HDL output, report output, sim output, etc) and base it's behavior off of
 * that returned file. Currently classes which all need to refer to (for
 * example) the Verilog HDL must refer to the static field member of the
 * VerilogTranslateEngine.
 * 
 * @author imiller Created on 03.17.2006
 */

public class ForgeFileHandler {
	/**
	 * A handle to the job, needed for accessing option values to generate names
	 * and locations
	 */
	private GenericJob job;

	/** The Map of the key to the File object. */
	private Map<ForgeFileKey, File> fileMap = new HashMap<ForgeFileKey, File>();

	public ForgeFileHandler(GenericJob job) {
		this.job = job;
	}

	/**
	 * registerFile permanently associates a given File with the specified key.
	 * A key may only be registered one time. The target File for the key is the
	 * file in the directory specified by 'base' and with the specified name.
	 */
	public File registerFile(ForgeFileKey key, File base, String name) {
		assert key != null : "Cannot use null as a file key";
		assert base != null : "Base dir cannot be null";
		assert name != null : "File name cannot be null";

		File newFile = new File(base, name);
		if (fileMap.containsKey(key) && !fileMap.get(key).equals(newFile))
			throw new IllegalArgumentException(
					"Cannot re-register the same file " + key);

		fileMap.put(key, newFile);
		return newFile;
	}

	/**
	 * registers a file with the specified name located in the destination
	 * directory.
	 */
	public File registerFile(ForgeFileKey key, String name) {
		return registerFile(key, getDestinationDir(), name);
	}

	/**
	 * Returns the file associated with the key. This method will throw an
	 * exception if the key has not been registered.
	 */
	public File getFile(ForgeFileKey key) {
		if (!fileMap.containsKey(key))
			throw new IllegalArgumentException("Unknown file key " + key);

		return fileMap.get(key);
	}

	/**
	 * Allows the handler to be queried as to whether a particular key has been
	 * registered.
	 */
	public boolean isRegistered(ForgeFileKey key) {
		return this.fileMap.containsKey(key);
	}

	/**
	 * Returns a string of the form <i>baseName</i>postFix.suffix
	 */
	public String buildName(String postFix, String suffix) {
		assert postFix != null;
		String baseName = this.job.getOutputBaseName();
		return baseName + postFix + (suffix != null ? ("." + suffix) : "");
	}

	/**
	 * This is a convenience method to get the destination directory for the
	 * files produced by forge. It checks for the -dfs (destination follows
	 * target) switch and if that is not set, it gets the value from the
	 * destination directory specified by the user.
	 * 
	 * @return Destination directory for files produced by forge.
	 */
	private File getDestinationDir() {
		if (this.job
				.getUnscopedBooleanOptionValue(OptionRegistry.DESTINATION_FOLLOWS_TARGET)) {
			File f = this.job.getTargetFiles()[0];
			return f.getParentFile();
		} else {
			Option op = this.job.getOption(OptionRegistry.DESTINATION_DIR);
			File f = new File(op.getValue(CodeLabel.UNSCOPED).toString());
			if (!f.isAbsolute()) {
				op = this.job.getOption(OptionRegistry.CWD);
				final String cwd = op.getValue(CodeLabel.UNSCOPED).toString();
				f = new File(cwd, f.getPath());
			}
			return f;
		}
	} // getDestinationDir()

}
